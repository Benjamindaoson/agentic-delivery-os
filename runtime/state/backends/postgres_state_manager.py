\"\"\"
Postgres-backed StateManager (async) using asyncpg.
Provides same interface as runtime/state/state_manager.py.
\"\"\"
from typing import Optional, Dict, Any
import asyncpg
import os
import json
\n+class PostgresStateManager:
    def __init__(self, database_url: str):
        self.database_url = database_url
        self.pool = None
\n+    async def initialize(self):
        \"\"\"Initialize connection pool and ensure tables exist.\"\"\"\n+        self.pool = await asyncpg.create_pool(self.database_url, min_size=1, max_size=5)
        async with self.pool.acquire() as conn:
            await conn.execute(\"\"\"\n+            CREATE TABLE IF NOT EXISTS tasks (\n+                task_id TEXT PRIMARY KEY,\n+                state TEXT NOT NULL,\n+                error TEXT,\n+                progress JSONB,\n+                context JSONB,\n+                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n+                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n+            );\n+            \"\"\")
            await conn.execute(\"\"\"\n+            CREATE TABLE IF NOT EXISTS state_transitions (\n+                id SERIAL PRIMARY KEY,\n+                task_id TEXT NOT NULL REFERENCES tasks(task_id),\n+                from_state TEXT,\n+                to_state TEXT NOT NULL,\n+                reason TEXT,\n+                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n+            );\n+            \"\"\")
\n+    async def create_task(self, task_id: str, spec: Dict[str, Any]):
        async with self.pool.acquire() as conn:
            await conn.execute(\n+                \"INSERT INTO tasks (task_id, state, context) VALUES ($1, $2, $3) ON CONFLICT (task_id) DO NOTHING\",\n+                task_id, \"IDLE\", json.dumps({\"spec\": spec})\n+            )\n+\n+    async def update_task_state(self, task_id: str, state: str, error: Optional[str] = None, progress: Optional[Dict] = None, reason: Optional[str] = None):\n+        progress_json = json.dumps(progress) if progress else None\n+        async with self.pool.acquire() as conn:\n+            # fetch current state\n+            row = await conn.fetchrow(\"SELECT state FROM tasks WHERE task_id = $1\", task_id)\n+            from_state = row[\"state\"] if row else None\n+            await conn.execute(\"\"\"\n+                INSERT INTO state_transitions (task_id, from_state, to_state, reason) VALUES ($1,$2,$3,$4)\n+            \"\"\", task_id, from_state, state, reason or f\"State transition to {state}\")\n+            await conn.execute(\"\"\"\n+                UPDATE tasks SET state = $1, error = $2, progress = $3, updated_at = CURRENT_TIMESTAMP WHERE task_id = $4\n+            \"\"\", state, error, progress_json, task_id)\n+\n+    async def get_task_state(self, task_id: str) -> Optional[Dict[str, Any]]:\n+        async with self.pool.acquire() as conn:\n+            row = await conn.fetchrow(\"SELECT task_id, state, error, progress, context FROM tasks WHERE task_id = $1\", task_id)\n+            if not row:\n+                return None\n+            return {\n+                \"task_id\": row[\"task_id\"],\n+                \"state\": row[\"state\"],\n+                \"error\": row[\"error\"],\n+                \"progress\": row[\"progress\"] or {},\n+                \"context\": row[\"context\"] or {}\n+            }\n+\n+    async def get_task_context(self, task_id: str) -> Dict[str, Any]:\n+        state = await self.get_task_state(task_id)\n+        return state.get(\"context\", {}) if state else {}\n+\n+    async def update_task_context(self, task_id: str, context: Dict[str, Any]):\n+        async with self.pool.acquire() as conn:\n+            await conn.execute(\"UPDATE tasks SET context = $1, updated_at = CURRENT_TIMESTAMP WHERE task_id = $2\", json.dumps(context), task_id)\n+\n+    async def get_state_transitions(self, task_id: str) -> list:\n+        async with self.pool.acquire() as conn:\n+            rows = await conn.fetch(\"SELECT from_state, to_state, reason, timestamp FROM state_transitions WHERE task_id = $1 ORDER BY timestamp ASC\", task_id)\n+            return [{\"from_state\": r[\"from_state\"], \"to_state\": r[\"to_state\"], \"reason\": r[\"reason\"], \"timestamp\": r[\"timestamp\"].isoformat()} for r in rows]\n+\n*** End Patch

